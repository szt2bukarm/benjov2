"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});class t{constructor(t,s,e,r=t<<16|s<<8|e){this.t=1,this.i=-1,this.o=-1,this.h=-1,this.u=-1,this.l=t,this.M=s,this.m=e,this.$=r}static distance(t,s){return(Math.abs(s.l-t.l)+Math.abs(s.M-t.M)+Math.abs(s.m-t.m))/765}clone(){const s=new t(this.l,this.M,this.m,this.$);return s.t=this.t,s}_(){const t=this.l/255,s=this.M/255,e=this.m/255,r=Math.max(t,s,e),n=Math.min(t,s,e);if(this.h=(r+n)/2,r===n)this.o=0,this.i=0,this.u=0;else{const i=r-n;switch(this.i=this.h>.5?i/(2-r-n):i/(r+n),this.u=this.i*(2*(.5-Math.abs(.5-this.h))),r){case t:this.o=((s-e)/i+(s<e?6:0))/6;break;case s:this.o=((e-t)/i+2)/6;break;case e:this.o=((t-s)/i+4)/6}}}get p(){return-1===this.o&&this._(),this.o}get C(){return-1===this.i&&this._(),this.i}get D(){return-1===this.h&&this._(),this.h}get j(){return-1===this.u&&this._(),this.u}}const s=(t,s)=>Math.abs(t-s);class e{constructor(){this.N=[],this.v=null}S(t){this.N.push(t),this.v=null}I(t,e,r,n){for(let h=0;h<this.N.length;h++){const a=this.N[h];if(!(i=a.p,o=t.p,Math.min(s(i,o),s((i+.5)%1,(o+.5)%1))<e&&s(a.C,t.C)<r&&s(a.D,t.D)<n))return!1}var i,o;return!0}get O(){if(!this.v){const{r:s,g:e,b:r}=this.N.reduce(((t,s)=>(t.r+=s.l,t.g+=s.M,t.b+=s.m,t)),{r:0,g:0,b:0}),n=this.N.reduce(((t,s)=>t+s.t),0);this.v=new t(Math.round(s/this.N.length),Math.round(e/this.N.length),Math.round(r/this.N.length)),this.v.t=n}return this.v}}class r{constructor(t,s,e){this.V=[],this.p=t,this.C=s,this.D=e}S(t){const s=this.V.find((s=>s.I(t,this.p,this.C,this.D)));if(s)s.S(t);else{const s=new e;s.S(t),this.V.push(s)}}L(){return this.V.map((t=>t.O))}}const n=({pixels:t=64e3,distance:s=.22,colorValidator:e=((t,s,e,r)=>(r??255)>250),hueDistance:r=.08333333333333333,saturationDistance:n=.2,lightnessDistance:i=.2,crossOrigin:o=null}={})=>{if(process.env.NODE_ENV !== "production"){const o=(t,s,e=0,r=Number.MAX_VALUE)=>{if(Number(s)!==s)throw new Error(`${t} is not a valid number (${s})`);return s<e&&console.warn(`${t} can not be less than ${e} (it's ${s})`),s>r&&console.warn(`${t} can not be more than ${r} (it's ${s})`),Math.min(Math.max(s,e),r)},h=(t,s)=>{if(!s||"[object Function]"!=={}.toString.call(s))throw new Error(`${t} is not a function (${s})`);return s};((t,s,e=0,r=Number.MAX_SAFE_INTEGER)=>{if(!Number.isInteger(s))throw new Error(`${t} is not a valid number (${s})`);return s<e&&console.warn(`${t} can not be less than ${e} (it's ${s})`),s>r&&console.warn(`${t} can not be more than ${r} (it's ${s})`),Math.min(Math.max(s,e),r)})("pixels",t||0,1),o("distance",s,0,1),h("colorValidator",e),o("hueDistance",r,0,1),o("saturationDistance",n,0,1),o("lightnessDistance",i,0,1)}return[Math.max(t,1),Math.min(Math.max(s,0),1),e,Math.min(Math.max(r,0),1),Math.min(Math.max(n,0),1),Math.min(Math.max(i,0),1),o]};class i{constructor(){this.t=0,this.P={}}S(s,e,r,n){return this.t++,this.P[s]?this.P[s].t++:this.P[s]=new t(e,r,n,s),this.P[s]}F(){return Object.keys(this.P).map((t=>this.P[t]))}k(){const t=this.F().reduce(((t,s)=>t.t>=s.t?t:s)).clone();return t.t=this.t,t}}class o{constructor(){this.t=0,this.P={}}F(){return Object.keys(this.P).map((t=>this.P[t]))}S(t,s,e){const r=t<<16|s<<8|e,n=(t>>4&15)<<8|(s>>4&15)<<4|e>>4&15;return this.t++,this.G(n).S(r,t,s,e)}G(t){return this.P[t]||(this.P[t]=new i),this.P[t]}H(s){const e=this.F().map((t=>t.k()));e.sort(((t,s)=>s.t-t.t));const r=[];for(;e.length;){const n=e.shift();e.filter((e=>t.distance(n,e)<s)).forEach((t=>{n.t+=t.t;const s=e.findIndex((s=>s===t));e.splice(s,1)})),r.push(n)}return r}}const h=({data:t,width:s,height:e},r,n,i)=>{const h=new o,a=s&&e&&Math.floor(s*e/r)||1;let c=0;for(let o=0;o<t.length;o+=4*a){const s=t[o],e=t[o+1],r=t[o+2];i(s,e,r,t[o+3])?h.S(s,e,r):c++}return{N:h.H(n),count:h.t+c}},a=()=>"undefined"!=typeof window,c=(t,s,e,n,i)=>{const o=((t,s,e,n,i)=>{const o=new r(e,n,i);t.forEach((t=>o.S(t)));const h=o.L();return h.sort(((t,e)=>(e.j+.1)*(.9-e.t/s)-(t.j+.1)*(.9-t.t/s))),h})(t,s,e,n,i);return o.map((t=>((t,s)=>({hex:`#${"0".repeat(6-t.$.toString(16).length)}${t.$.toString(16)}`,red:t.l,green:t.M,blue:t.m,area:t.t/s,hue:t.p,saturation:t.C,lightness:t.D,intensity:t.j}))(t,s)))},u=(t,s={})=>{const[e,r,i,o,a,u]=n(s),{N:l,count:d}=h(t,e,r,i);return c(l,d,o,a,u)},l=(t,s={})=>{if(a()){const[e,r,i,o,a,u,l]=n(s);return t.crossOrigin=l,new Promise((s=>{const n=t=>{const n=((t,s)=>{const e=t.width*t.height,r=e<s?t.width:Math.round(t.width*Math.sqrt(s/e)),n=e<s?t.height:Math.round(t.height*Math.sqrt(s/e)),i=document.createElement("canvas");i.width=r,i.height=n;const o=i.getContext("2d");return o.drawImage(t,0,0,t.width,t.height,0,0,r,n),o.getImageData(0,0,r,n)})(t,e),{N:l,count:d}=h(n,e,r,i);s(c(l,d,o,a,u))};if(t.complete)n(t);else{const s=()=>{t.removeEventListener("load",s),n(t)};t.addEventListener("load",s)}}))}if(process.env.NODE_ENV !== "production")throw new Error("Can not use extractColorsFromImage for Node.js")},d=(t,s={})=>{if(a()){const e=new Image;return e.src=t,l(e,s)}if(process.env.NODE_ENV !== "production")throw new Error("Can not use extractColorsFromSrc for Node.js")};exports.extractColors=(t,s)=>{if(!a()){if(process.env.NODE_ENV !== "production"){if(t instanceof String)throw new Error("Send imageData to extractColors (Image src or HTMLImageElement not supported in Nodejs)");if(!t.data)throw new Error("Send imageData to extractColors");(null==s?void 0:s.crossOrigin)&&console.warn("options.crossOrigin not supported in Node.js")}return new Promise((e=>{e(u(t,s))}))}if(t instanceof Image)return l(t,s);if(t instanceof ImageData||t instanceof Object&&t.data)return new Promise((e=>{e(u(t,s))}));if("string"==typeof t)return d(t,s);throw new Error("Can not analyse picture")},exports.extractColorsFromImage=l,exports.extractColorsFromImageData=u,exports.extractColorsFromSrc=d;
//# sourceMappingURL=extract-colors.cjs.map
